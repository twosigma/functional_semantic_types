#
# Copyright 2024 Two Sigma Open Source, LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import pandas as pd
import numpy as np
from jinja2 import Environment, BaseLoader
from semantic_type_base_classes import create_string_representation_of_general_classes, create_string_representation_of_imports_for_general_types

def sem_types_to_general_sem_type_prompt(list_of_sem_type_classes):
    sem_types_prompt = \
    """ You are GroupGPT, an assistant that will receive a list of Python class definitions and return a single class that spans them all. For context, each class represents a Semantic Type, which is a real-world entity that corresponds to some piece of columnar data I have collected. Each type has its own attributes, specified formatting, and a cast() function that takes as input a single value from the column and returns a formatted, casted value. You will populate the following class using the instructions from the comments:

{{general_sem_type_class_def}}

Notes:
- For super_cast(), I want your code to be ROBUST, and handle ALL of the outputs generated by the cast() of the provided classes
- For validate(), I want your code to sanity-check that the value is correct. 
- Feel free to use external libraries for either method, just DECLARE IMPORTS AT THE TOP of the class. you can use: [numpy, pandas, re, pycountry, time]
- MOST IMPORTANT: make sure that your solution compiles and will execute when I instantiate the class.
- A useful strategy for "picking" a canonical format, is to pick the format of ONE class, and convert any output from the cast() of the provided classes to that format.

Here is an example. Notice how the output of super_cast() can only be ['male', 'female', 'other']. It is SUPER IMPORTANT that super_cast() is a SURJECTIVE mapping, i.e. mapping a broad set of values, in this case [1,2, 'male', 'female', 'other'] from the cast() methods to a single, canonical representation:

CLASSES = ```
class gender(CategoricalSemanticType):
    def __init__(self):
        self.description = "The gender of a pilot"
        self.valid_values = "Gender can be: MALE, FEMALE, OTHER"
        self.format = "upper-cased string"
        self.examples = ['MALE', 'FEMALE', 'OTHER', 'MALE', 'FEMALE']
    
    def cast(self, val):
        lower_string_val = str(val).upper()
        if val not in ['MALE', 'FEMALE', 'OTHER']:
            raise Exception()
        else:
            return lower_string_val
class gender(CategoricalSemanticType):
    def __init__(self):
        self.description = "the gender of a human"
        self.valid_values = "Gender is either: 1, 2"
        self.format = "A number"
        self.examples = [1,2,1,2,1]
    
    def cast(self, val):
        int_val = int(val)
        if int_val in [1,2]:
            return int_val
        else:
            raise Exception()
```
RETURN=
class gender(GeneralSemanticType):
    def __init__(self):
        self.description = "A gender"
        self.format = "In lower-case and as a string"

    def super_cast(self, val):
        if isinstance(val, str) and val.isdigit():
            int_val = int(val)
            if int_val == 1:
                return 'male'
            elif int_val == 2:
                return 'female'
            else:
                return 'other'
        else:
            return str(val).lower()

    def validate(self, val):
        casted_val = self.super_cast(val)
        if casted_val in ['male', 'female', 'other']:
            return True
        else:
            return False

I want you to output a single class that INHERITS GenericSemanticType (but change the class name). Do not add any extra text, ```, or "python" prefixes. I just want the class definition. Also the class names should be real-world entities, spelled correctly and SHOULD BE LOWERCASE. JUST GIVE ME WORKING PYTHON CODE, I have a lot dependening on this.
- SUPER IMPORTANT: I will provide you with the list of libraries to start with, don't import anything else. Just start writing the classes definitions and Mapping dictionary. Make sure your class definition names don't conflict with the imports.

CLASSES = ```
{{class_defs}}
```
RETURN=
{{necessary_imports}}
"""
    definition_prompt_template = Environment(loader=BaseLoader).from_string(sem_types_prompt)
    str_joined_class_defs = '\n'.join([
        item.replace('from semantic_type_base_classes_gen import *', '').strip('\n') for item in list_of_sem_type_classes
    ])
    next_prompt = definition_prompt_template.render(
        {
            'general_sem_type_class_def': create_string_representation_of_general_classes()['GeneralSemanticType'],
            'class_defs': str_joined_class_defs,
            'necessary_imports': create_string_representation_of_imports_for_general_types()
        }
    )
    return next_prompt